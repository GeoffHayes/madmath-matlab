%**************************************************************************
% The class encapsulates information concerning a range observation
% that is generated by a sensor at a fixed position.
%**************************************************************************
% If you have any questions, comments, or find bugs, please feel free to 
% email me at geoff.hayes74@gmail.com.
%
% Geoff Hayes 2014
%**************************************************************************
classdef ObservationRange < Observation
   
    properties (Constant, Access=public)
       % Number of dimensions in the range observation vector.
       DIMS  = 1;
       % Index of the range data in the observation vector.
       RANGE  = 1;
    end  
    
    properties
        % observation state vector
        z         = zeros(ObservationRange.DIMS,1);
        % observation covariance matrix for the state vector
        R         = zeros(ObservationRange.DIMS,ObservationRange.DIMS); 
        % position of sensor which the range is relative to
        sensorPos = zeros(2,1);
    end
    
    methods

        % class constructor
        function [obs] = ObservationRange()
            
            % call the superclass constructor
            obs = obs@Observation();
           
        end         
        
        function [H] = getH(obs,trk)
            
            if isa(trk,'Track2DPV')

                % calculate the first order partial derivatives around x,
                % y, vx, and vy using the track state vector and the sensor
                % position according to the equation:
                %    range = sqrt((x-xs)^2 + (y-ys)^2)) where (x,y) is the
                % position of the track and (xs,ys) is the position of the
                % sensor
                xSubxs = trk.x(Track2DPV.XPOS) - obs.sensorPos(1);
                ySubys = trk.x(Track2DPV.YPOS) - obs.sensorPos(2);              
                
                drBydx  = xSubxs/sqrt(xSubxs^2 + ySubys^2);
                drBydy  = ySubys/sqrt(xSubxs^2 + ySubys^2);
                drBydvx = 0;
                drBydvy = 0;
                
                H = [drBydx drBydy drBydvx drBydvy];
                
            end
            
        end
        
        function [y] = getY(obs,trk,H)
            
            if isa(trk,'Track2DPV')
                xSubxs = trk.x(Track2DPV.XPOS) - obs.sensorPos(1);
                ySubys = trk.x(Track2DPV.YPOS) - obs.sensorPos(2);  
                r = sqrt(xSubxs^2 + ySubys^2);
                y = obs.z - r;
            end
            
        end        
        
        function [trk] = initTrack(~,trk)
            
            if isa(trk,'Track2DPV')
                % cannot initialize a 2DPV track with a range observation
                % so throw an exception
                error(['ObservationRange::initTrack ' ...
                       'Track2DPV cannot be initialized with a range observation!']);
            end  
            
        end
        
        % output methods
        function [str] = asString(obs)
            str = [obs.asString@Observation() ' z:' mat2str(obs.z) ' R:' mat2str(obs.R)];
        end
        
        function display(obs)
            disp(obs.asString());
        end        
    end
end

